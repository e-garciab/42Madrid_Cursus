/*OPCION 2: GUARDANDO TODO EL STRING EN UN BUFFER E IMPRIMIENDOLO AL FINAL*/
/*
void	signal_handler(int sig, siginfo_t *info, void *context)
{
	static int  bit_count; //cuenta cuántos bits han llegado
	static pid_t    client_pid; //guarda el pid del cliente actual
	static unsigned char    c; //almacena el caracter en construcción
	static char *buffer;
		//espacio donde iremos guardando cada caracter
	static int index;
		//indicará la posición actual en el buffer (donde meter el siguiente caracter)
	char *new_buff;
	
	(void)context;
	if(client_pid != info->si_pid) //si el pid del cliente cambia,se resetea el caracter y el contador para evitar errores y mezclas.
	{
		client_pid=info->si_pid;
		bit_count = 0;
		c = 0;
		index = 0;
		if(buffer)
		{
			free(buffer);
			buffer = NULL;
		}
		// new_buff = NULL;
	}
	c = c << 1; //desplaza los bits de c una posición a la izquierda,lo que abre un hueco al final para añadir un nuevo bit
	if(sig == SIGUSR1)
		c = c | 1; //asegura que el último bit es 1. Si la señal recibida fue SIGUSR2 no hace falta hacer nada porque al hacer el shift ya pusiste un cero al final.
	bit_count++;
	if(bit_count == 8)
	{
		new_buff = malloc((index + 1 + 1) * sizeof(char));
		if(!new_buff)
		{
			ft_putstr_fd("Memory allocation failed", 1);
			exit(EXIT_FAILURE);
		}
		if(buffer)
		{
			ft_memcpy(new_buff, buffer, index);
			free(buffer);
			// buffer=NULL;
		}
		new_buff[index] = c;
		new_buff[index + 1] = '\0';
		buffer=new_buff;
		//free(new_buff);
		//new_buff=NULL;
		index++;
		if(c == '\0') //significa que ya se ha recibido la cadena completa,hay que imprimirla
		{
			ft_putstr_fd(buffer, 1);
			ft_putstr_fd("\n", 1);
			free(buffer);
			buffer = NULL;
			index=0;
			//BONUS:ENVIAR SEÑAL DE CONFIRMACION DE MENSAJE FINALIZADO
		}
		c=0;
		bit_count=0;
	}
	if(kill(client_pid, SIGUSR2) == -1)
	{
		ft_putstr_fd("Error sending confirmation\n", 2);
	 	exit(EXIT_FAILURE);
	}
}
*/


/*OPCION 1: ENVIANDO A IMPRIMIR CARACTER A CARACTER*/
/*
void	signal_handler(int sig, siginfo_t *info, void *context)
{
	static int bit_count;    // cuenta cuántos bits han llegado
	static pid_t client_pid; // guarda el pid del cliente actual
	static unsigned char c;  // almacena el caracter en construcción
	(void)context;
	if (client_pid != info->si_pid) // si el pid del cliente cambia,
		se resetea el caracter y el contador para evitar errores y mezclas.
	{
		bit_count = 0;
		c = 0;
	}
	client_pid = info->si_pid;
		// actualiza el client_pid para mantener el mismo emisor
	c = c << 1;               
		// desplaza los bits de c una posición a la izquierda,
		// lo que abre un hueco al final para añadir un nuevo bit
	if (sig == SIGUSR1)
		c = c | 1;
			// asegura que el último bit es 1. Si la señal recibida fue SIGUSR2 no hace falta hacer nada porque al hacer el shift ya pusiste un cero al final.
	bit_count++;
	if (bit_count == 8)
	{
		if (c == '\0')
		{
			write(1, "\n", 1);
			kill(client_pid, SIGUSR1); // REVISAR PARA BONUS
				// - ENVIAR CONFIRMACION DE FIN DEL MENSAJE.
		}
		else
			write(1, &c, 1);
		bit_count = 0;
		c = 0;
	}
	if (kill(client_pid, SIGUSR2) == -1)
	{
		ft_putstr_fd("Error sending confirmation\n", 2);
		exit(EXIT_FAILURE);
	}
}
*/